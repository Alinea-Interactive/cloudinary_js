// Generated by CoffeeScript 1.10.0
(function() {
  module.exports = function(grunt) {
    var gruntOptions, repo, repoTargets, repos, t, umdHeader;
    repos = ['cloudinary-core', 'cloudinary-core-shrinkwrap', 'cloudinary-jquery', 'cloudinary-jquery-file-upload'];

    /**
     * Create a task configuration that includes the given options item + a sibling for each target
     * @param {object} options - options common for all targets
     * @param {object|function} repoOptions - options specific for each repository
     * @returns {object} the task configuration
     */
    repoTargets = function(options, repoOptions) {
      var i, len, repo;
      if (options == null) {
        options = {};
      }
      if (repoOptions == null) {
        repoOptions = {};
      }
      if (options.options == null) {
        options = {
          options: options
        };
      }
      for (i = 0, len = repos.length; i < len; i++) {
        repo = repos[i];
        options[repo] = (typeof repoOptions === "function" ? repoOptions(repo) : void 0) || repoOptions;
      }
      return options;
    };
    umdHeader = function(dependency, dependencyVar) {
      return "((root, factory) ->\n  if (typeof define == 'function') && define.amd\n    define  ['" + dependency + "'], factory\n  else if typeof exports == 'object'\n    module.exports = factory(require('" + dependency + "'))\n  else\n    root.cloudinary ||= {}\n    root.cloudinary = factory(" + dependencyVar + ")\n)(this,  (" + dependencyVar + ")->\n";
    };
    gruntOptions = {
      pkg: grunt.file.readJSON('package.json'),
      coffee: {
        sources: {
          expand: true,
          bare: false,
          sourceMap: true,
          cwd: 'src',
          src: ['**/*.coffee'],
          dest: 'src',
          ext: '.js'
        },
        test: {
          expand: true,
          cwd: 'test/spec',
          src: ['*.coffee'],
          dest: 'test/spec',
          ext: '.js'
        },
        build: {
          expand: true,
          bare: false,
          sourceMap: true,
          cwd: 'build',
          src: ['*.coffee'],
          dest: 'build',
          ext: '.js'
        }
      },
      uglify: {
        build: {
          options: {
            sourceMap: true,
            mangle: false
          },
          files: (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = repos.length; i < len; i++) {
              repo = repos[i];
              results.push({
                src: ["build/" + repo + ".js"],
                dest: "build/" + repo + ".min.js",
                ext: '.min.js'
              });
            }
            return results;
          })()
        }
      },
      karma: repoTargets({
        reporters: ['dots'],
        configFile: 'karma.coffee',
        browserDisconnectTolerance: 3
      }, function(repo) {
        var repoFiles;
        repoFiles = (function() {
          switch (false) {
            case !repo.match(/shrink/):
              return ["build/" + repo + ".js"];
            case !repo.match(/upload/):
              return ["bower_components/jquery/dist/jquery.js", 'bower_components/jquery.ui/ui/widget.js', 'bower_components/blueimp-file-upload/js/jquery.fileupload.js', 'bower_components/blueimp-file-upload/js/jquery.fileupload-process.js', 'bower_components/blueimp-file-upload/js/jquery.iframe-transport.js', 'bower_components/blueimp-file-upload/js/jquery.fileupload-image.js', "build/" + repo + ".js", 'test/spec/cloudinary-jquery-spec.js', 'test/spec/cloudinary-jquery-upload-spec.js'];
            case !repo.match(/jquery/):
              return ["bower_components/jquery/dist/jquery.js", "build/" + repo + ".js", 'test/spec/cloudinary-jquery-spec.js'];
            default:
              return ["bower_components/lodash/lodash.js", "build/" + repo + ".js"];
          }
        })();
        return {
          files: [
            {
              src: repoFiles.concat(['test/spec/cloudinary-spec.js', 'test/spec/tagspec.js', 'test/spec/videourlspec.js', 'test/spec/chaining-spec.js'])
            }
          ]
        };
      }, repos.concat((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = repos.length; i < len; i++) {
          t = repos[i];
          results.push(t + ".min");
        }
        return results;
      })())),
      jsdoc: repoTargets({
        options: {},
        amd: {
          src: ['src/**/*.js', './README.md'],
          options: {
            destination: 'doc/amd',
            template: 'template',
            configure: "jsdoc-conf.json"
          }
        }
      }, function(repo) {
        return {
          src: ["build/" + repo + ".js", './README.md'],
          options: {
            destination: "doc/pkg-" + repo,
            template: 'template',
            configure: "jsdoc-conf.json"
          }
        };
      }),
      clean: {
        build: ["build"],
        doc: ["doc"],
        js: ["js"]
      },
      copy: {
        'backward-compatible': {
          files: [
            {
              expand: true,
              flatten: true,
              src: ["bower_components/blueimp-canvas-to-blob/js/canvas-to-blob.min.js", "bower_components/blueimp-load-image/js/load-image.all.min.js", "bower_components/blueimp-file-upload/js/jquery.fileupload-image.js", "bower_components/blueimp-file-upload/js/jquery.fileupload-process.js", "bower_components/blueimp-file-upload/js/jquery.fileupload-validate.js", "bower_components/blueimp-file-upload/js/jquery.fileupload.js", "bower_components/blueimp-file-upload/js/jquery.iframe-transport.js", "bower_components/blueimp-file-upload/js/vendor/jquery.ui.widget.js"],
              dest: "js/"
            }, {
              src: 'build/cloudinary-jquery-file-upload.js',
              dest: 'js/jquery.cloudinary.js'
            }
          ]
        },
        dist: {
          files: (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = repos.length; i < len; i++) {
              repo = repos[i];
              results.push({
                'src': "build/" + repo + ".js",
                'dest': "../pkg/pkg-" + repo + "/" + repo + ".js"
              });
            }
            return results;
          })()
        },
        doc: {
          files: (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = repos.length; i < len; i++) {
              repo = repos[i];
              results.push({
                expand: true,
                cwd: "doc/pkg-" + repo + "/",
                src: ["**"],
                dest: "../pkg/pkg-" + repo + "/"
              });
            }
            return results;
          })()
        }
      },
      version: {
        options: {
          release: 'patch'
        },
        "package": {
          src: ['bower.json', 'package.json']
        },
        source: {
          options: {
            prefix: 'VERSION\\s+=\\s+[\'"]'
          },
          src: ['src/cloudinary.coffee']
        },
        dist: {
          files: (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = repos.length; i < len; i++) {
              repo = repos[i];
              results.push({
                src: ["../pkg/pkg-" + repo + "/bower.json", "../pkg/pkg-" + repo + "/package.json"],
                dest: "../pkg/pkg-" + repo + "/"
              });
            }
            return results;
          })()
        }
      },
      concat: repoTargets({
        process: function(src, path) {
          return "  " + src.replace(/\n/g, "\n  ");
        }
      }, function(repo) {
        var defineArray, dependency, dependencyVar, ref, requireVar, srcList, utilFile;
        ref = (function() {
          switch (false) {
            case !/shrinkwrap/.test(repo):
              return ["", "", ["build/lodash-shrinkwrapped.coffee", "src/util/lodash.coffee"]];
            case !/core/.test(repo):
              return ["lodash", '_', "src/util/lodash.coffee"];
            case !/jquery/.test(repo):
              return ["jquery", "jQuery", "src/util/jquery.coffee"];
            default:
              return ["", "", ""];
          }
        })(), dependency = ref[0], dependencyVar = ref[1], utilFile = ref[2];
        srcList = ['src/utf8_encode.coffee', 'src/crc32.coffee', utilFile, 'src/parameters.coffee', 'src/transformation.coffee', 'src/configuration.coffee', 'src/tags/htmltag.coffee', 'src/tags/imagetag.coffee', 'src/tags/videotag.coffee', 'src/cloudinary.coffee'];
        if (/jquery/.test(repo)) {
          srcList.push('src/cloudinaryjquery.coffee');
        }
        if (/upload/.test(repo)) {
          srcList.push('src/jquery-file-upload.coffee');
        }
        defineArray = requireVar = "";
        if ((dependency != null ? dependency.length : void 0) > 0) {
          defineArray = "['" + dependency + "'],";
          requireVar = "require('" + dependency + "')";
        }
        return {
          options: {
            banner: "((root, factory) ->\n  if (typeof define == 'function') && define.amd\n    define  " + defineArray + " factory\n  else if typeof exports == 'object'\n    module.exports = factory(" + requireVar + ")\n  else\n    root.cloudinary ||= {}\n    root.cloudinary = factory(" + dependencyVar + ")\n)(this,  (" + dependencyVar + ")->\n",
            footer: "\n  cloudinary =\n    utf8_encode: utf8_encode\n    crc32: crc32\n    Util: Util\n    Transformation: Transformation\n    Configuration: Configuration\n    HtmlTag: HtmlTag\n    ImageTag: ImageTag\n    VideoTag: VideoTag\n    Cloudinary: Cloudinary\n    " + (/jquery/.test(repo) ? "CloudinaryJQuery: CloudinaryJQuery" : "") + "\n\n  cloudinary\n)"
          },
          src: srcList,
          dest: "build/" + repo + ".coffee"
        };
      })
    };
    console.log(JSON.stringify(gruntOptions));
    grunt.initConfig(gruntOptions);
    grunt.loadNpmTasks('grunt-contrib-concat');
    grunt.loadNpmTasks('grunt-contrib-coffee');
    grunt.loadNpmTasks('grunt-contrib-uglify');
    grunt.loadNpmTasks('grunt-contrib-requirejs');
    grunt.loadNpmTasks('grunt-contrib-copy');
    grunt.loadNpmTasks('grunt-contrib-clean');
    grunt.loadNpmTasks('grunt-jsdoc');
    grunt.loadNpmTasks('grunt-karma');
    grunt.loadNpmTasks('grunt-version');
    grunt.registerTask('default', ['concat', 'coffee']);
    grunt.registerTask('build', ['clean', 'lodash', 'concat', 'coffee', 'jsdoc', 'copy:backward-compatible']);
    return grunt.registerTask('lodash', function(name, target) {
      var func, i, include, len, lodashCalls;
      lodashCalls = grunt.file.read('src/util/lodash.coffee').match(/_\.\w+/g);
      include = [];
      for (i = 0, len = lodashCalls.length; i < len; i++) {
        func = lodashCalls[i];
        if (include.indexOf(func.slice(2)) < 0) {
          include.push(func.slice(2));
        }
      }
      return require('lodash-cli')(["include=" + (include.join(',')), "exports=none", "--output", "build/lodash-shrinkwrapped.js", "--development"], function(data) {
        var outputPath, sourceMap;
        outputPath = data.outputPath;
        sourceMap = data.sourceMap;
        console.dir(data);
        if (outputPath) {
          grunt.file.write(outputPath, data.source);
          grunt.file.write(outputPath.slice(0, -3) + ".coffee", "\n`" + (data.source.replace(/`/g, "'")) + "`");
          if (sourceMap) {
            return grunt.file.write(path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.map'), sourceMap);
          }
        }
      });
    });
  };

}).call(this);
